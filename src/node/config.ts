import fs from "fs";
import path from "path";
import { Plugin } from "./plugin";
import { ResolvedServerOptions, ServerOptions } from "./server";
import { createDebugger, isObject, lookupFile, normalizePath } from "./utils";
import { resolvePlugins } from "./plugins";
import chalk from "chalk";
import { CLIENT_DIR, DEFAULT_ASSETS_RE } from "./constants";
import {
  InternalResolveOptions,
  ResolveOptions,
  resolvePlugin,
} from "./plugins/resolve";
import { createLogger, Logger, LogLevel } from "./logger";
import { DepOptimizationOptions } from "./optimizer";
import { createFilter } from "@rollup/pluginutils";
import {
  createPluginContainer,
  PluginContainer,
} from "./server/pluginContainer";
import { build } from "esbuild";

const debug = createDebugger("vite:config");

// NOTE: every export in this file is re-exported from ./index.ts so it will
// be part of the public API.
export interface ConfigEnv {
  command: "build" | "serve";
  mode: string;
}

export type UserConfigFn = (env: ConfigEnv) => UserConfig | Promise<UserConfig>;
export type UserConfigExport = UserConfig | Promise<UserConfig> | UserConfigFn;

/**
 * Type helper to make it easier to use vite.config.ts
 * accepts a direct {@link UserConfig} object, or a function that returns it.
 * The function receives a {@link ConfigEnv} object that exposes two properties:
 * `command` (either `'build'` or `'serve'`), and `mode`.
 */
export function defineConfig(config: UserConfigExport): UserConfigExport {
  return config;
}

export type PluginOption = Plugin | false | null | undefined;

export interface UserConfig {
  /**
   * Project root directory. Can be an absolute path, or a path relative from
   * the location of the config file itself.
   * @default process.cwd()
   */
  root?: string;
  /**
   * Base public path when served in development or production.
   * @default '/'
   */
  base?: string;
  /**
   * Directory to serve as plain static assets. Files in this directory are
   * served and copied to build dist dir as-is without transform. The value
   * can be either an absolute file system path or a path relative to <root>.
   *
   * Set to `false` or an empty string to disable copied static assets to build dist dir.
   * @default 'public'
   */
  publicDir?: string | false;
  /**
   * Directory to save cache files. Files in this directory are pre-bundled
   * deps or some other cache files that generated by vite, which can improve
   * the performance. You can use `--force` flag or manually delete the directory
   * to regenerate the cache files. The value can be either an absolute file
   * system path or a path relative to <root>.
   * @default 'node_modules/.vite'
   */
  cacheDir?: string;
  /**
   * Explicitly set a mode to run in. This will override the default mode for
   * each command, and can be overridden by the command line --mode option.
   */
  mode?: string;
  /**
   * Define global variable replacements.
   * Entries will be defined on `window` during dev and replaced during build.
   */
  define?: Record<string, any>;
  /**
   * Array of vite plugins to use.
   */
  plugins?: (PluginOption | PluginOption[])[];
  /**
   * Configure resolver
   */
  resolve?: ResolveOptions & { alias?: any };
  /**
   * CSS related options (preprocessors and CSS modules)
   */
  // css?: CSSOptions;
  /**
   * JSON loading options
   */
  json?: any;
  /**
   * Transform options to pass to esbuild.
   * Or set to `false` to disable esbuild.
   */
  esbuild?: any | false;
  /**
   * Specify additional files to be treated as static assets.
   */
  assetsInclude?: string | RegExp | (string | RegExp)[];
  /**
   * Server specific options, e.g. host, port, https...
   */
  server?: ServerOptions;
  /**
   * Build specific options
   */
  build?: any;
  /**
   * Dep optimization options
   */
  optimizeDeps?: DepOptimizationOptions;
  /**
   * SSR specific options
   * @alpha
   */
  ssr?: SSROptions;
  /**
   * Log level.
   * Default: 'info'
   */
  logLevel?: LogLevel;
  /**
   * Default: true
   */
  clearScreen?: boolean;
  /**
   * Environment files directory. Can be an absolute path, or a path relative from
   * the location of the config file itself.
   * @default root
   */
  envDir?: string;
  /**
   * Import aliases
   * @deprecated use `resolve.alias` instead
   */
  alias?: any;
  /**
   * Force Vite to always resolve listed dependencies to the same copy (from
   * project root).
   * @deprecated use `resolve.dedupe` instead
   */
  dedupe?: string[];
}

export type SSRTarget = "node" | "webworker";

export interface SSROptions {
  external?: string[];
  noExternal?: string | RegExp | (string | RegExp)[];
  /**
   * Define the target for the ssr build. The browser field in package.json
   * is ignored for node but used if webworker is the target
   * Default: 'node'
   */
  target?: SSRTarget;
}

export interface InlineConfig extends UserConfig {
  configFile?: string | false;
  envFile?: false;
}

export type ResolvedConfig = Readonly<
  Omit<
    UserConfig,
    "plugins" | "alias" | "dedupe" | "assetsInclude" | "optimizeDeps"
  > & {
    configFile: string | undefined;
    configFileDependencies: string[];
    inlineConfig: InlineConfig;
    root: string;
    base: string;
    publicDir: string;
    command: "build" | "serve";
    mode: string;
    isProduction: boolean;
    env: Record<string, any>;
    resolve: ResolveOptions & {
      alias: any[];
    };
    plugins: readonly Plugin[];
    server: ResolvedServerOptions;
    build: any;
    assetsInclude: (file: string) => boolean;
    logger: Logger;
    createResolver: (options?: Partial<InternalResolveOptions>) => ResolveFn;
    optimizeDeps: Omit<DepOptimizationOptions, "keepNames">;
  }
>;

export type ResolveFn = (
  id: string,
  importer?: string,
  aliasOnly?: boolean,
  ssr?: boolean
) => Promise<string | undefined>;

export async function resolveConfig(
  inlineConfig: InlineConfig,
  command: "build" | "serve",
  defaultMode = "development"
): Promise<ResolvedConfig> {
  let config = inlineConfig;
  let configFileDependencies: string[] = [];
  let mode = "development"; // inlineConfig.mode || defaultMode;  // 目前只支持 ‘development’

  const configEnv = {
    mode,
    command,
  };

  let { configFile } = config; // configFile 是 undefined
  if (configFile !== false) {
    const loadResult = await loadConfigFromFile(
      configEnv,
      configFile,
      config.root,
      config.logLevel
    );
    if (loadResult) {
      config = mergeConfig(loadResult.config, config);
      configFile = loadResult.path;
      configFileDependencies = loadResult.dependencies;
    }
  }

  // Define logger
  const logger = createLogger(config.logLevel, {
    allowClearScreen: config.clearScreen,
  });

  // user config may provide an alternative mode
  mode = config.mode || mode;

  // resolve plugins
  const rawUserPlugins = (config.plugins || []).flat().filter(p => {
    return p && (!p.apply || p.apply === command);
  }) as Plugin[];
  // 事实上，目前只有 prePlugins：react-refresh
  // const [prePlugins, normalPlugins, postPlugins] =
  //   sortUserPlugins(rawUserPlugins);

  const prePlugins = rawUserPlugins,
    normalPlugins = [],
    postPlugins = [];
  // run config hooks
  const userPlugins = rawUserPlugins;
  // resolve root
  const resolvedRoot = normalizePath(
    config.root ? path.resolve(config.root) : process.cwd()
  );

  // resolve alias with internal client alias
  const resolvedAlias = mergeAlias(
    // #1732 the CLIENT_DIR may contain $$ which cannot be used as direct
    // replacement string.
    // @ts-ignore because @rollup/plugin-alias' type doesn't allow function
    // replacement, but its implementation does work with function values.
    [{ find: /^\/@vite\//, replacement: () => CLIENT_DIR + "/" }],
    config.resolve?.alias || config.alias || []
  );

  const resolveOptions: ResolvedConfig["resolve"] = {
    dedupe: config.dedupe,
    ...config.resolve,
    alias: resolvedAlias,
  };

  // load .env files
  // const envDir = config.envDir
  //   ? normalizePath(path.resolve(resolvedRoot, config.envDir))
  //   : resolvedRoot;
  const userEnv = inlineConfig.envFile !== false && {}; // loadEnv(mode, envDir);

  // Note it is possible for user to have a custom mode, e.g. `staging` where
  // production-like behavior is expected. This is indicated by NODE_ENV=production
  // loaded from `.staging.env` and set by us as VITE_USER_NODE_ENV
  const isProduction = false;

  // resolve public base url
  const BASE_URL = "/";

  // resolve cache directory
  const pkgPath = lookupFile(
    resolvedRoot,
    [`package.json`],
    true /* pathOnly */
  );
  const cacheDir = config.cacheDir
    ? path.resolve(resolvedRoot, config.cacheDir)
    : pkgPath && path.join(path.dirname(pkgPath), `node_modules/.vite`);

  const assetsFilter = config.assetsInclude
    ? createFilter(config.assetsInclude)
    : () => false;

  // create an internal resolver to be used in special scenarios, e.g.
  // optimizer & handling css @imports
  const createResolver: ResolvedConfig["createResolver"] = options => {
    let aliasContainer: PluginContainer | undefined;
    let resolverContainer: PluginContainer | undefined;
    return async (id, importer, aliasOnly, ssr) => {
      let container: PluginContainer;
      if (aliasOnly) {
        // container =
        //   aliasContainer ||
        //   (aliasContainer = await createPluginContainer({
        //     ...resolved,
        //     plugins: [aliasPlugin({ entries: resolved.resolve.alias })]
        //   }))
      } else {
        container =
          resolverContainer ||
          (resolverContainer = await createPluginContainer({
            ...resolved,
            plugins: [
              // aliasPlugin({ entries: resolved.resolve.alias }),
              resolvePlugin({
                ...resolved.resolve,
                root: resolvedRoot,
                isProduction,
                isBuild: command === "build",
                ssrTarget: resolved.ssr?.target,
                asSrc: true,
                preferRelative: false,
                tryIndex: true,
                ...options,
              }),
            ],
          }));
      }
      return (await container?.resolveId(id, importer, undefined, ssr))?.id;
    };
  };

  const { publicDir } = config;
  const resolvedPublicDir =
    publicDir !== false && publicDir !== ""
      ? path.resolve(
          resolvedRoot,
          typeof publicDir === "string" ? publicDir : "public"
        )
      : "";

  const resolved: ResolvedConfig = {
    ...config,
    configFile: configFile ? normalizePath(configFile) : undefined,
    configFileDependencies,
    inlineConfig,
    root: resolvedRoot,
    base: BASE_URL,
    resolve: resolveOptions,
    publicDir: resolvedPublicDir,
    cacheDir,
    command,
    mode,
    isProduction,
    plugins: userPlugins,
    server: {
      middlewareMode: "ssr",
      watch: { usePolling: true, interval: 100 },
      fs: {
        strict: undefined,
        allow: [resolvedRoot],
      },
    },
    build: {
      target: ["es2019", "edge88", "firefox78", "chrome87", "safari13.1"],
      polyfillDynamicImport: false,
      outDir: "dist",
      assetsDir: "assets",
      assetsInlineLimit: 4096,
      cssCodeSplit: true,
      sourcemap: false,
      rollupOptions: {},
      commonjsOptions: { include: [{}], extensions: [".js", ".cjs"] },
      dynamicImportVarsOptions: { warnOnError: true, exclude: [{}] },
      minify: false,
      terserOptions: {},
      cleanCssOptions: {},
      write: true,
      emptyOutDir: null,
      manifest: false,
      lib: false,
      ssr: false,
      ssrManifest: false,
      brotliSize: true,
      chunkSizeWarningLimit: 500,
      watch: null,
    },
    env: {
      ...userEnv,
      BASE_URL,
      MODE: mode,
      DEV: !isProduction,
      PROD: isProduction,
    },
    assetsInclude(file: string) {
      return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
    },
    logger,
    createResolver,
    optimizeDeps: {
      ...config.optimizeDeps,
      esbuildOptions: {
        keepNames: config.optimizeDeps?.keepNames,
        ...config.optimizeDeps?.esbuildOptions,
      },
    },
  };

  (resolved.plugins as Plugin[]) = await resolvePlugins(
    resolved,
    prePlugins,
    normalPlugins,
    postPlugins
  );

  // call configResolved hooks
  await Promise.all(userPlugins.map(p => p.configResolved?.(resolved)));

  return resolved;
}

function mergeConfigRecursively(
  a: Record<string, any>,
  b: Record<string, any>,
  rootPath: string
) {
  const merged: Record<string, any> = { ...a };
  for (const key in b) {
    const value = b[key];
    if (value == null) {
      continue;
    }

    const existing = merged[key];
    if (Array.isArray(existing) && Array.isArray(value)) {
      merged[key] = [...existing, ...value];
      continue;
    }
    if (isObject(existing) && isObject(value)) {
      merged[key] = mergeConfigRecursively(
        existing,
        value,
        rootPath ? `${rootPath}.${key}` : key
      );
      continue;
    }

    // fields that require special handling
    if (existing != null) {
      if (key === "alias" && (rootPath === "resolve" || rootPath === "")) {
        merged[key] = mergeAlias(existing, value);
        continue;
      } else if (key === "assetsInclude" && rootPath === "") {
        merged[key] = [].concat(existing, value);
        continue;
      }
    }

    merged[key] = value;
  }
  return merged;
}

export function mergeConfig(
  a: Record<string, any>,
  b: Record<string, any>,
  isRoot = true
): Record<string, any> {
  return mergeConfigRecursively(a, b, isRoot ? "" : ".");
}

function mergeAlias(a: any = [], b: any = []): any[] {
  return [...normalizeAlias(a), ...normalizeAlias(b)];
}

function normalizeAlias(o: any): any[] {
  return Array.isArray(o)
    ? o.map(normalizeSingleAlias)
    : Object.keys(o).map(find =>
        normalizeSingleAlias({
          find,
          replacement: (o as any)[find],
        })
      );
}

// https://github.com/vitejs/vite/issues/1363
// work around https://github.com/rollup/plugins/issues/759
function normalizeSingleAlias({ find, replacement }: any): any {
  if (
    typeof find === "string" &&
    find.endsWith("/") &&
    replacement.endsWith("/")
  ) {
    find = find.slice(0, find.length - 1);
    replacement = replacement.slice(0, replacement.length - 1);
  }
  return { find, replacement };
}

// export function sortUserPlugins(
//   plugins: (Plugin | Plugin[])[] | undefined
// ): [Plugin[], Plugin[], Plugin[]] {
//   const prePlugins: Plugin[] = [];
//   const postPlugins: Plugin[] = [];
//   const normalPlugins: Plugin[] = [];

//   if (plugins) {
//     plugins.flat().forEach(p => {
//       if (p.enforce === "pre") prePlugins.push(p);
//       else if (p.enforce === "post") postPlugins.push(p);
//       else normalPlugins.push(p);
//     });
//   }

//   return [prePlugins, normalPlugins, postPlugins];
// }

export async function loadConfigFromFile(
  configEnv: ConfigEnv,
  configFile?: string | undefined,
  configRoot: string = process.cwd(),
  logLevel?: LogLevel
): Promise<{
  path: string;
  config: UserConfig;
  dependencies: string[];
} | null> {
  const start = Date.now();

  let resolvedPath: string | undefined;
  let dependencies: string[] = [];
  const tsconfigFile = path.resolve(configRoot, "vite.config.ts");
  if (fs.existsSync(tsconfigFile)) {
    resolvedPath = tsconfigFile;
  }

  try {
    // if we reach here, the file is ts or using es import syntax, or
    // the user has type: "module" in their package.json (#917)
    // transpile es import syntax to require syntax using rollup.
    // lazy require rollup (it's actually in dependencies)
    const bundled = await bundleConfigFile(resolvedPath);
    dependencies = bundled.dependencies;
    let userConfig = (await loadConfigFromBundledFile(
      resolvedPath,
      bundled.code
    )) as UserConfigExport;
    debug(`bundled config file loaded in ${Date.now() - start}ms`);

    const config = await (typeof userConfig === "function"
      ? userConfig(configEnv)
      : userConfig);
    return {
      path: normalizePath(resolvedPath),
      config,
      dependencies,
    };
  } catch (e) {
    createLogger(logLevel).error(
      chalk.red(`failed to load config from ${resolvedPath}`)
    );
    throw e;
  }
}

async function bundleConfigFile(
  fileName: string,
  mjs = false
): Promise<{ code: string; dependencies: string[] }> {
  const result = await build({
    absWorkingDir: process.cwd(),
    entryPoints: [fileName],
    outfile: "out.js",
    write: false,
    platform: "node",
    bundle: true,
    format: mjs ? "esm" : "cjs",
    sourcemap: "inline",
    metafile: true,
    plugins: [
      {
        name: "externalize-deps",
        setup(build) {
          build.onResolve({ filter: /.*/ }, args => {
            const id = args.path;
            if (id[0] !== "." && !path.isAbsolute(id)) {
              return {
                external: true,
              };
            }
          });
        },
      },
      {
        name: "replace-import-meta",
        setup(build) {
          build.onLoad({ filter: /\.[jt]s$/ }, async args => {
            const contents = await fs.promises.readFile(args.path, "utf8");
            return {
              loader: args.path.endsWith(".ts") ? "ts" : "js",
              contents: contents
                .replace(
                  /\bimport\.meta\.url\b/g,
                  JSON.stringify(`file://${args.path}`)
                )
                .replace(
                  /\b__dirname\b/g,
                  JSON.stringify(path.dirname(args.path))
                )
                .replace(/\b__filename\b/g, JSON.stringify(args.path)),
            };
          });
        },
      },
    ],
  });
  const { text } = result.outputFiles[0];
  return {
    code: text,
    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : [],
  };
}

interface NodeModuleWithCompile extends NodeModule {
  _compile(code: string, filename: string): any;
}

async function loadConfigFromBundledFile(
  fileName: string,
  bundledCode: string
): Promise<UserConfig> {
  const extension = path.extname(fileName);
  const defaultLoader = require.extensions[extension]!;
  require.extensions[extension] = (module: NodeModule, filename: string) => {
    if (filename === fileName) {
      (module as NodeModuleWithCompile)._compile(bundledCode, filename);
    } else {
      defaultLoader(module, filename);
    }
  };
  // clear cache in case of server restart
  delete require.cache[require.resolve(fileName)];
  const raw = require(fileName);
  const config = raw.__esModule ? raw.default : raw;
  require.extensions[extension] = defaultLoader;
  return config;
}
